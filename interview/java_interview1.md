
1. Java의 Collections Framework에 대해 간단하게 설명해주세요.
Array, List, Set, Map, Stack, Queue 의 차이점과 각 자료 구조가 적합한 사용 사례를 예로 들어 설명해주세요.

Java Collections Framework(JCF) 는 자바진영에서 제공하는 Collections(집합) 자료구조 모음(추상형, 구현체 모두 제공) 입니다.

Array : 배열 고정된 크기를 가지고 있는 자료형으로 특정 인덱스를 통해 검색이 필요한경우 List 자료형 대비 빠른 조회를 보장합니다. 다만 배열은 선언시 할당된 크기를 임의로 늘릴수 없으므로 데이터가 생성되고 삽입/삭제는 일어나지않지만 조회를 많이하는경우에 효과적입니다.   
List : 리스트는 배열 대비 조회가 느리다는 단점이 있지만 삽입 삭제등에서 강점을 가지고있습니다.   
Set : 집합 자료형으로 중복과 순서가 없습니다. 중복이 없어야되는 경우 사용할 수 있습니다. (로또 번호 등)   
Map : 맵 K->V 형태의 자료형으로 KEY를 통해 VALUE를 찾는 구조의 자료형입니다. 
Stack : 스택(Stacke)은LIFO(Last in First Out) 자료구조로 입력 데이터가 마지막 입력된 순으로 출력 함을 보장 할때 사용 합니다. 대표적 사용예로는 브라우저의 `뒤로가기 버튼` 이 있으며 이는 이전의 브라우저 탐색결과를 최신순 을 기준으로 돌아가기를 실행 합니다.   
Queue : 큐(Queue)는 FIFO(First in First out) 자료구조로 입력 데이터가 선입력된 순으로 출력 함을 보장 할때 사용 합니다. 대표적인 예로 MessageQueue, Transection 의 처리가 있습니다.   
메세지큐(MessageQueue)에서의 큐 : 이벤트 처리에 대해서 입력된 순서대로 처리합니다. (이벤트의 입력 과 처리는 순서를 보장해야 합니다.)   
트랜잭션에서(Transaction)의 큐 : 트랜잭션의 실행결과는 실행순서에 영향을 받을 수 있기에 각 트랜잭션은 순차적으로 실행됩니다.   

2. Garbage Collection의 개념과 실제로 어떻게 메모리 관리가 이루어지는지 CMS, G1, Z GC 중 하나를 예로 들어 설명해주세요.

Garbage Collection(이하 GC)는 프로그래밍 실행중 힙 영역에서 불필요한 데이터(Garbage) 를 처리하는 역할을 담당합니다.   

> Mark & sweep 이해하기   
> JAVA 의 GC 가 실행될떄 기본적으로 살아 있는 객체(접근 가능한 객체) 에 mark(살아있음을 표시) 하고 mark 되지않은 객체를 sweep(청소,정리) 함으로써 GC가 동작하며 메모리를 반환합니다.

> STW(Stop the world)는 GC 동작에의해 어플리케이션이 멈추는 현상입니다.
   
> GC는 어떻게 불필요한 객체를 추적하나요 ? 🤔
> GC 프로그램 root space(JVM 실행중인 STACK)을 시작으로 각각 stack에서 사용하는 객체의 연결을 추적합니다.


CMS GC는 Concurrent Mark & sweap 으로 다음과 같은 4가지 단계를 밟습니다.

Initial Mark: GC Root가 참조하는 객체만 마킹 (STW 발생 )
Concurrent Mark: 참조하는 객체를 따라가며, 지속적으로 마킹.
Remark: concurrent mark 과정에서 변경된 사항이 없는지 다시 한번 마킹하며 확정하는 과정. (STW 발생)
Concurrent Sweep: 접근할 수 없는 객체를 제거하는 과정



3. API 통신에서 JSON 데이터 포맷을 사용할 때의 장점과 단점은 무엇인지 설명해주세요.
만약 단점이 있다면, 이를 어떻게 해결할 수 있는지에 대한 방안을 제시해주세요.

API 통신에서 JSON 데이터 포맷을 사용할 때의 장점은 우선 사용자, 개발자 모두가 JSON 데이터를 읽고,쓰고 가공하기 쉽다는점입니다.

단점으로는 사용자, 개발자가 읽고 쓰기 편하기위해 처리되는 작업들 입니다. JSON 포맷으로 표현하기위해 서버측에서는 해당데이터를 컴퓨터가 인식하는 2진코드(바이트코드) 에서 사람이 읽을수 있는 데이터로 변경해야합니다.(문자열 등) 바이트 코드를 사람이 읽을 수 있는 JSON 등이 다른 포맷으로 변경하는 과정을 역직렬화라 하며 이과정 에서 데이터의 크기가 증가하게됩니다. 서버가 연산을 수행하고 역직렬화된 데이터를 클라이언트에 넘겨줄때 증가한 데이터 크기만큼의 오버헤드 가 발생하게됩니다.

그럼 어떻게 개선 할 수 있을까 ?

JSON 포맷을 변경하지 않는 경우:
기존의 RESTAPI는 정해진 데이터 포맷을 넘겨주게 됩니다. 하지만 이를 graphql과 함께 사용할 경우 전체 JSON 데이터가 아닌 사용자가 필요한 데이터에 대해서 만 요청/응답 하게 되므로 기존의 RESTAPI대비 경량화된 JSON을 주고 받음으로써 네트워크 비용 감소의 효과를 누릴수 있습니다. 다만 여전히 역직렬화 /직렬화 과정이 필요하기에 추가적인 연산이 필요합니다.또 추가적으로 Graphql 학습 비용과 API 설계 변경 비용을 고려해야 합니다.

JSON 포맷을 변경하는 경우:
기존의 JSON 포맷의 문제점으로 직렬화/역직렬화 로인한 데이터 크기증가와 네트워크 비용이였습니다. 직렬화/역직렬화 과정을 없엔 gRPC 통신 방법을 사용할 수 있습니다.
gRPC는 기존의 JSON 포맷처럼 사용자, 개발자가 읽을수 있는 문자데이터를 주고 받는게 아닌 컴퓨터의 이진코드를 주고 받게됩니다. 이를 도입함으로써 클라이언트- 서버 간의 데이터 통신비용이 JSON 대비 효과적으로 줄일 수 있습니다. 하지만 효과적인 장점만 있는것은 아닙니다. gRPC를 이용한 이진코드로 데이터를 주고 받기위해 여러가지 통신 규약이 필요로합니다. 클라이언트- 서버 간 모두 gRPC를 통신하기위해 어떻게 통신을 하며 어떤 데이터를 주고받을것인지 클라이언트, 서버 모두 알고있어야하며 이러한 사실은 서버- 클라이언트의 강한 결합을 유발하게 됩니다. 또 gRPC 로 통신을 하는것은 컴퓨터가 이해할수있는 이진코드로 데이터를 주고받기에 디버깅과 데이터 추적등의 어려움이 있을 수 있습니다.
또 기존의 JSON 과 다르게 통신방법에 대한 새로운 학습이 필요합니다.